#import "../templates/acronyms.typ": acr

= Vertiefungsteil
Für den Vertiefungsteil habe Ich mir das Thema „Entwicklung einer nativen Anwendung mittels React, Electron und C++" gewählt. da es sich um eines der Hauptthemen in dieser Arbeit handelt. Die Hauptarchitektur zeichnet sich dadurch aus, dass eine mittels React entwickelte Benutzeroberflächemit einem Teil komuniziert, der mit der Kvaser-Hardware kommuniziert. Alternativ gäbe es auch den Ansatz, das User-Interface mittels eines Systems namens React-Native zu entwickeln. Daher wurde sich allerdings entschieden, da einige wichtige Funktionalitäten der #acr("JS")-Sprache noch nicht einwandfrei unterstützt und das viele Aspekte im Code umständlicher gestalten würden. Zudem ist die ausgewählte Komponente #acr("LIB") noch nicht für React-Native verfügbar beziehungsweise stellten sich in einer kurzen Testphase massive Kompatibilitätsprobleme heraus. Eine weitere Alternative wäre gewesen, anstatt von C++ ein „Backend" mit Csharp zu bauen. Zu diesem Ansatz wurden im Vorhinein auch intensive Recherchen betrieben. Diese haben ergeben, dass es zu massiven Performanceverlusten kommen kann, vorallem, wenn viele Nachrichten zwischen dem #acr("JS")-Teil und dem Backend ausgetauscht werden müssen. Da dies die Hauptaufgabe ist, ist dieser Performanceeinbruch absolut nicht tolerabel.

== Electron, Funationalitäten und Arbeitsweise
Da, wie bereits beschriben,n aus Performancegründen die Wahl auf reines React gefallen ist, kann dies nur mittels eines Electron-Wrappers ermöglicht werden. Electron agiert an dieser Stelle ähnlich zu einem Webbrowser, in dem das Userinterface ähnlich einer normalen Webseite angezeigt wird. Dies wird ermöglicht, indem Electron von Haus aus mit seiner eigenen Kopie von Chrome kommt. Dies hat den Vorteil, dass das fertige Programm nicht auf andere, vorinstallierte Programme angewiesen ist. Leider wird aber dann in jeder mittels Electron entwickelten Anwendung ein komplettes Paket von Chrome ausgeliefert, was die fertige EXE doch sehr groß macht. Zudem kommt noch Hinzu, dass Chrome bekannt für seinen hohen Speicherbedarf ist und somit auch nicht perfekt auf schwächeren Systemen läuft. Electron ist aber nicht nur das im Browser angezeigte Frontend, sondern auch die komplette NodeJS-Umgebung, die es erlaubt, die komplette Backend-Logik im gleichen Programm mitlaufen zu lassen.Im Besonderen ist in diesem Projekt die Kompatibilität mit Node-Native wichtig, die seit 2020 standardmäßig in Electron gegeben ist. Mittels der NAPI-API lassen sich ganz normale Node-native Module einbinden, allerdings müssen diese natürlich auf die Zielarchitektur angepasst werden. Genauer wird auf die Entwicklung des Nativ-Teils in einem späteren Kapitel eingegangen. Die Kommunikation zwischen dem Frontend und dem Backend kann auf zwei Weisen erreicht werden. Einerseits können Daten wie gewohnt mittels REST abgefragt werden oder mittels speziellen #acr("IPC")-Nachrichten. REST hat einige Nachteile. Einerseits ist dieses Protokoll nur darauf ausgelegt, dass sich die Daten geholt werden. Zum Anderen hat man aufgrund der Kommunikation einen erheblichen Flaschenhalseffekt. Daher ist die Wahl auf eine Datenübertragung mittels #acr("IPC") gefallen. Dabei werden Späzielle, so genannte „ Inter-Process-Communication“-Pakete vom Backend geschickt. Diese werden daraufhin von einem Hook im #acr("JS") aufgefasst und verarbeitet. Die Verarbeitung gestaltet sich darin, dass man für jede #acr("IPC")-Adresse eine Funktion angibt. Die aufgerufen werden soll, sobald eine Nachricht mit diesem Typ detektiert wurde.

#pagebreak()
== Laufwege in der WebApp und Electron
Grundlegend besteht die Aufgabe darin, ein sogennantes #acr("CAN") Daten Paket zu empfangen, und dieses dann anzuzeigen.
Ein solches Paket ist wie folgt aufgebaut:
#figure(
  table(
    columns: (1fr, 1fr, 1fr),
    inset: 10pt,
    align: left,
    table.header([*Field*], [*Length (bits)*], [*Description*]),
    [Identifier], [11 (Standard) / 29 (Extended)], [Bestimmt die wichtigkeit und priorität.],
    [RTR (Remote Transmission Request)],
    [1],
    [Zeigt an, ob es sich um einen Daten-Frame oder einen Remote-Frame (Anforderung von Daten) handelt.],

    [IDE (Identifier Extension Bit)], [1], [Bei erweiterten Rahmen wird dieses Bit auf 1 gesetzt.],
    [#acr("DBC") (Data Length Code)], [4], [Gibt die Länge des Datenfeldes an (in Bytes, 0-8 Bytes).],
    [Data], [0–64 (0–8 bytes)], [Die tatsächlich übertragenen Daten (maximal 8 Byte).],
    [CRC (Cyclic Redundancy Check)], [15], [Fehlererkennungscode (wird für die Fehlerprüfung verwendet).],
  ),
)
Das Empfangen dieser Frames wird schon vom C++-Native-Teil übernommen. Sobald ein solcher Frame fertig empfangen wurde,wird er in eine JSON-Struktur umgewandelt, welche dann an einen #acr("JS")-Handler übergeben wird. Dieser Handler kümmert sich darumm, dass an den jeweiligen stellen, an denen die Daten benötigt werden, diese auch vorliegen. Hauptsächlich handelt es sich um die sogenannten View-Tiles, welche im Dashboard frei konfigurierbar angeordnet werden können.Sobald ein solches Tile benachrichtigt wurde, dass Daten zur Verfügung stehen, wird anhand einer so genannten #acr("DBC")-Datei entschieden,Welche Datenschipsel wirklich wichtig sind. Wenn eine Filterung konfiguriert ist, wird über (je nach Einstellung 2-10) die Datenwerte das arithmetische Mittel gebildet.und diese dann angezeigt.Eine #acr("DBC")-Datei beschreibt hierbei den Aufbau und die Bedeutung der einzelnen Bits und verleiht ihnen dann schlussendlich die benötigte Bedeutung.Diese Dateien können in einem separaten Tab verwaltet werden und stehen danach überall in der App zur Verfügung.

== Nativer C++ Code
Der C++-Teil des Systems ist quasi das Herzstück des Systems. Er kümmert sich um das Empfangen der Nachrichten via der vor Kvaser bereitgestellten #acr("API").
Bei Kvaser handelt es sich neben Vektor um einen der größten Hersteller von #acr("CAN")-Bus-zu-USB-Adaptern, und daher sind diese Interfaces auch stark in der Industrie vertreten. Es gibt zudem auch einige Alternativen, die vollständig Open Source sind,allerdings sind die dann oftmals nicht so gut supported, was in einem Business-Context nicht tragbar ist. Kvaser stellt für jedes ihrer Produkte eine sehr gut dokumentierte #acr("API") zur Verfügung, mittels der es möglich ist, #acr("CAN")-Bus-Nachrichten zu senden und empfangengen. Die Verarbeitung läuft folgendermaßen ab: Zuerst wird beim Systemtreiber nachgefragt, welche Interfaces verbunden sind und was deren jeweiliger Verfügbarkeitszustand ist. Beispielsweise kann ein Dongle vom Windows-Treiber erkannt worden sein, aber schon von einem anderen Programm verwendet werden. Diese Interfaces dürften natürlich nicht verwendet werden.
#linebreak()
Sollte ein Dongle erkannt worden sein, der nicht anderweitig in Verwendung ist, so wird dieser von ApolloLink besetzt und vorkonfiguriert. Bei diesem Prozess wird ein sogenannter Hook gesetzt, was so viel bedeutet wie dass eine Funktion angegeben wird, wie bei jeder empfangenen Nachricht aufgerufen wird. Dabei werden auch alle Empfangsdaten, also Nachricht #acr("ID"), #acr("DBC"), der Timestamp und am wichtigsten das Array mit den Datenbytes, übergeben. Der Empfangs-Hook wandelt den empfangenen Datensatz dann in ein #acr("JS")-Objekt um, welches darauf mittels #acr("IPC") an das Frontend übermittelt wird.
#linebreak()
Wenn Daten zum Senden bereitstehen, wird das #acr("JS")-Objekt zerlegt und an die Sende-Funktion der Kvaser #acr("API") übergeben. Der tatsächliche Sendungsprozess läuft dann asynchron und vollautomatisch ab. Sobald also ein Slot auf dem physischen Bus zur Verfügung steht, wird der #acr("CAN")-Frame gesendet.
#linebreak()
#linebreak()
Im C++-Kern werden aber nur die Funktionalitäten der Kvaser-#acr("API") so weit abstrahiert, dass es später auch möglich sein wird, andere Interfaces zu unterstützen. Die tatsächliche Einteilung in logische Objekte wird mittels #acr("TS") realisiert, da dadurch eine Integration in das große System stark vereinfacht wird. Alles zusammen wird in einem Node-Paket ausgeliefert, welches schon für die gängigsten Betriebssysteme und Architekturen vorkompiliert wurde, was eine Einbindung sehr angenehm gestaltet. Für die Electron-Anwendung sieht das gesamte Paket aus wie jedes andere Node-Paket.
